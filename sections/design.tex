%  Explain your design methodology, such as your design steps, lab work
%  partitioning, special techniques used, etc. Clearly explain any
%  special programming considerations (e.g., explain how and why you set
%  up control registers, how and why you check for flags, etc.)

\section{Design Solution}
\subsection{Planning}
\subsubsection{Work Partitioning}
Based on experience from the first lab, and personal preference, lab
work was partitioned accordingly. The project was split into the
embedded programming and accessory circuit design/implementation, where
the majority of the embedded programming was assigned to Tayler Mulligan
and the accessory timer circuit to Raymond Bamford. The partitioning was
not strict, with members collaborating where necessary or convenient.

\subsubsection{Technique and Technologies}
Git and GithHub were utilized for the project to provide team access and
syncing between lab computers (see
\url{https://github.com/tamul/ceng355-lab-project}). The source code was
split into three files: \filename{main.c} (see \ref{app:main}), containing the main program;
\filename{analog.c} (see \ref{app:analog}), containing \gls{adc},
\gls{dac}, and frequency monitoring
code; and \filename{lcd.c} (see \ref{app:lcd}), containing code related
to the \gls{lcd}; each
with corresponding header files.

\subsection{Implementation}
The main program called functions provided by \lstinline{analog.h} and
\lstinline{lcd.h} to sequentially initialize each component. Components
were initialized in the order of: the \gls{adc}, the \gls{dac}, the
\gls{lcd}, and the frequency monitor. 

\lst{Initialization order}{code:init-order}{42}{57}{src/main.c}

\subsubsection{\gls{adc} Initialization}
Initialization of the gls{adc} requires initialization of the \gls{gpio}
(port C) interface (to control the POT\_EN signal of the Project Board),
GPIOC (to read the potentiometer value), and the gls{adc}. The C code in
Listing~\ref{code:adc-gpioc-conf} comprises the initialization of the
GPIOC register for the gls{adc}.

\lst{\gls{gpio} configuration for \gls{adc}}{code:adc-gpioc-conf}{36}{48}{src/analog.c}

Firstly, the GPIOC clock is ensured to be running, followed by
configuration of the pins. The pins are put in a push-pull output
configuration at the highest speed, without any pull-up or pull-down
resistors. The GPIOA clock is guaranteed to be running as the
communication between the computer and \gls{stm} are over the parallel
A ports. The PA0 pin is set to ``analog'' mode. \\

\lst{\gls{adc} configuration}{code:adc-conf}{50}{73}{src/analog.c}

Next the \gls{adc} proper is initialized: the C code in
Listing~\ref{code:adc-conf} accomplishes this.  The \gls{hsi} clock, which
supplies the \gls{adc}'s clock, is enabled and the gls{adc} started in preparation
for configuration. Lines~57-68 configure the gls{adc}: setting the clock as
the dedicated (\gls{hsi}) clock, selecting input channel 0 (corresponding to
parallel port A0), continuous conversion mode is enabled to continuously
provide the digitized value of the PA0 pin. Finally, the function
triggers conversion to start after waiting until the gls{adc} reports that it
has stabilized.

\subsubsection{\gls{dac} Initialization}
Enabling the \gls{dac} requires configuration of the PA4 pin and
initialization of the \gls{dac} clock. Listing~\ref{code:dac-init} shows
the C code initializing the \gls{dac}.

\lst{\gls{dac} configuration}{code:dac-init}{78}{92}{src/analog.c}

The mode of PA4 is set to an open-drain analog output, allowing a
variable voltage to be placed on PA4, with pull-up and pull-down
pins disabled, at the highest speed setting to ensure the pin updates
quickly. Next, the \gls{dac}'s clock is enabled and the \gls{dac}
enabled by writing the \gls{dac}'s \gls{cr}'s enable bit.

\subsubsection{\gls{lcd} Initialization}

To initialize the \gls{lcd}, the \lcd{spi}, GPIOB, and GPIOC clocks are
all initialized (Listing~\ref{code:lcd-init-clocks}).

\lst{\gls{spi}, GPIOB, GPIOC clock enable}{code:lcd-init-clocks}{15}{21}{src/lcd.c}

The \gls{lck} pin (PC2) of the \gls{spi} shift-register is set to output
mode, and the \gls{mosi} (PB5) and \gls{sck} (PB3) \gls{spi} pins are
set to alternate function mode (Listing~\ref{code:lcd-init-output}).

\lst{\gls{spi} pin mode configuration}{code:lcd-init-output}{23}{30}{src/lcd.c}

Each \gls{spi} related pin is set to push-pull mode with pull-up and
pull-down resistors disabled and high-speed mode
(Listing~\ref{code:lcd-init-output-conf}).

\lst{\gls{spi} pin output configuration}{code:lcd-init-output-conf}{32}{45}{src/lcd.c}

After configuring the output pins, \gls{tim3} is configured, allowing
\gls{spi} writes to be delayed and the \gls{lcd} time to complete
the commands sent:

\lst{\gls{tim3} configuration}{code:lcd-tim3-conf}{47}{62}{src/lcd.c}

The clock for \gls{tim3} is enabled, then the clock is configured to use
buffered auto-reload, count down from the set \lstinline{CNT} register
value, stop in the event of an overflow (which should never occur), and
only interrupt in the event of an overflow not when the counter reaches
0. This configuration allows a value to be written to the timer which
then counts down to 0, and the timer can be polled until the count is
low enough (and enough time has passed), then allowing another command to be
sent. This avoids the potential for an overflow if the counter was
initialized to zero and counted up to or past the desired value. \\

The prescaler is set to 0, the auto-reload delay set to the lowest
possible, writing to the \lstinline{EGR} register is a carry-over from
other timer initializations and is not necessary in this case; then, the
\lstinline{MAX\_DELAY} value (the maximum time the LCD will take to
execute a command) is loaded into the timer's \lstinline{CNT}
register, and the timer finally started.

Next, in Listing~\ref{code:spi-init}, \gls{spi} is configured and
enabled with: unidirectional transmit, master mode, a data-size of 8
bits, a falling edge clock pulse, software chip select, a 256 baud-rate
prescaler, \gls{msb} first output, and a 7 bit \gls{crc} polynomial.

\lst{\gls{spi} initialization}{code:spi-init}{64}{78}{src/lcd.c}

Finally, in Listing~\ref{code:lcd-init}, the command interface and
the display of the \gls{lcd} are initialized: the \gls{lcd} is set to a
4-bit interface with 2 lines, followed by the LCD being cleared and
homed with display shift disabled and cursor movement direction set to
the right, cursor blinking being disabled. The persistent, unchanging
characters of the \gls{ui} are then written to the \gls{lcd}.

\lst{\gls{lcd} initialization}{code:lcd-init}{80}{113}{src/lcd.c}
